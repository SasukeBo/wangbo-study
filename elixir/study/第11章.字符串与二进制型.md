# 字符串与二进制型

## 字符串字面量

Elixir有两种字符串，用单引号和用双引号括起来的。它们最主要的区别是内部表示形式。
但它们也有很多共同点。
* 字符串支持UTF-8编码的字符。
* 可以包含转义字符。
* 允许在Elixir表达式中通过语法#{...}来插值。
* 可以使用反斜杠对有特殊意义的字符进行转义。
* 支持heredoc。


### Heredoc

对多行字符串使用IO.write。IO.puts总是会在字符串结尾加上换行符。

```elixir
IO.write "
    my
    string
    "
IO.write """
  my
  string
  """
```
heredoc 被广泛用于给函数和模块添加文档。

### 魔术符

魔术符以波浪符开头，后接一个大写或小写字母，然后是一些用分隔符限定的内容，可能还有一些选项。

分隔符可以是<...>、{...}、[...]、(...)、|...|、/.../、"..."、'...'
其中的字母决定了魔术符的类型，例如：

```
~C 字符列表，不支持转义或插值
~c 字符列表，支持类似单引号字符串的转义和插值
~R 正则表达式，不支持转义和插值
~r 正则表达式，支持转义和插值
~S 字符串，不支持转义和插值
~s 字符串，类似双引号字符串，支持转义和插值
~W 以空格分割的单词列表，不支持转义或插值
~w 以空格分割的单词列表，支持转义或插值
```

下面是一些例子：

```elixir
~C[1\n2#{1 + 2}]
~c"1\n2#{1 + 2}"
~S[1\n2#{1 + 2}]
~s/1\n2#{1 + 2}/
~W[the c#{'a'}t sat on the mat]
~w[the c#{'a'}t sat on the mat]
```

## “字符串”这个名称

Elixir的约定是，我们只会称双引号字符串时为字符串，单引号的形式是字符列表。
两者区别很大，用于字符串的库也只适合用于双引号形式。

## 单引号字符串——字符编码列表

单引号字符串会被表示为整数值列表，每个值对应字符串中的一个编码点。

```elixir
str = 'wombat'
is_list str
length str
Enum.reverse str
```

令人疑惑的是，iex将其显示为字符串，这是由于当列表中每个数字都是可打印字符时，
iex会将这个整数列表以字符串的形式打印出来。

你可以以多种方式来查看内部表示：

```elixir
:io.format "~w~n", [str]
List.to_tuple str
str ++ [0]
```

格式串中的~w强制将str以Erlang类型，底层的整数列表输出。~n为换行。

因为字符列表也是列表，常规的模式匹配和List函数都适用。

```elixir
'pole' ++ 'vault'
'pole' -- 'vault'
List.zip['abc', '123']
[head | tail] = 'cat'
```

下面这个简单的模块用于解析字符列表表示法，该表示法用于表示任意的有符号十进制数字。
将字符列表转换为整数。

```elixir
# codes/parse.exs
defmodule Parse do

  def number([ ?- | tail ]), do: _number_digits(tail, 0) * -1
  def number([ ?+ | tail ]), do: _number_digits(tail, 0)
  def number(str),           do: _number_digits(tail, 0)

  defp _number_digits([], value), do: value
  defp _number_digits([ digit | tail ], value)
  when digit in '0123456789' do
    _number_digits(tail, value * 10 + digit - ?0)
  end

  defp _number_digits([ non_digit | _ ], _) do
    raise "Invalid digit '#{[non_digit]}'"
  end
end
```

```elixir
c "parse.exs"
Parse.number '123'
Parse.number '-123'
Parse.number '+123'
Parse.number '+9'
Parse.number '+a'
```

* 习题：StringsAndBinaries-1

```elixir
# codes/StringsAndBinaries.exs
defmodule MyStrings do
  def is_ASCII([head | tail]) do
    if head > ?\s - 1 && head < ?~ + 1 do
      is_ASCII(tail)
    else
      false
    end
  end

  def is_ASCII([]), do: true
end
```

* 习题：StringsAndBinaries-2.exs

```elixir
# codes/StringsAndBinaries.exs
defmodule MyStrings do
  def anagram?(word1) do
    Enum.reverse(word1) == word1
  end
end
```

* 习题：StringsAndBinaries-3.exs

```elixir
# codes/StringsAndBinaries.exs
defmodule MyStrings do
  def calculate(expression) when is_list expression do
    analyze(expression, 0)
  end

  # when里面不能使用&&，||，！，可以使用 and、or、not
  defp analyze([head | tail], value) when (head >= ?0 and head <= ?9) do
    analyze(tail, value * 10 + (head - ?0))
  end
  defp analyze([head | tail], value) when head == ?+ do
    value + analyze(tail, 0)
  end
  defp analyze([head | tail], value) when head == ?- do
    value - analyze(tail, 0)
  end
  defp analyze([head | tail], value) when head == ?* do
    value * analyze(tail, 0)
  end
  defp analyze([head | tail], value) when head == ?/ do
    value / analyze(tail, 0)
  end
  defp analyze([head | tail], value) when head == ?\s do
    analyze(tail, value)
  end
  defp analyze([], value), do: value
end
```

## 二进制型

二进制表示位的序列,
二进制型字面值是这样子的：<< term, ... >>。

最简单的项就是0至255的数字。数字以连续字节存储在二进制型中。

```elixir
b = << 1, 2, 3 >>
byte_size b
bit_size b
```

你可以通过指定修饰符来设定任意项的大小（以二进制位为单位）。
这在处理二进制格式的数据（例如媒体文件和网络数据包）时非常有用。

```elixir
# b = 00001001
b = <<1::size(2), 1::size(3)>>
byte_size b
bit_size b
```

你可以在二进制型中存储整数、浮点数和其他二进制数据。

```elixir
int = << 1 >>
float = << 2.5 :: float >>
mix = <<int :: binary, float :: binary>>
```

IEEE 754标准的浮点数包含符号位、指数、底数，可以提取这些字段

```elixir
<<sign::size(1), exp::size(11), mantissa::size(52)>> = <<3.1415926::float>>
(1 + mantissa / :math.pow(2, 52)) * :math.pow(2, exp - 1023)
```

## 双引号字符串是二进制型


